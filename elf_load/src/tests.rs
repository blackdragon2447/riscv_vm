mod elf_header {
    use crate::{
        data::{AbiType, Endianess, ObjectType, ASI},
        elf_header::ElfHeader,
        error::ElfHeaderParseError,
        Address,
    };

    #[test]
    fn load() -> Result<(), ElfHeaderParseError> {
        let bytes = vec![
            0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x02, 0x00, 0xf3, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
            0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x42,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00,
            0x04, 0x00, 0x40, 0x00, 0x09, 0x00, 0x08, 0x00,
        ];

        let header = ElfHeader::from_bytes(&bytes)?;

        assert_eq!(
            header,
            ElfHeader {
                bitness: crate::data::Bitness::B64,
                endianess: Endianess::Little,
                abi_type: AbiType::SystemV,
                abi_ver: 0,
                obj_type: ObjectType::Exec,
                arch: ASI::RISCV,
                entry: Address(0x80000000),
                p_header: 64,
                s_header: 17048,
                flags: 0x0,
                p_header_size: 56,
                p_header_ecount: 4,
                s_header_size: 64,
                s_header_ecount: 9,
                s_header_name_entry: 8
            }
        );

        Ok(())
    }

    #[test]
    fn invalid_magic() {
        let bytes = vec![
            0x7f, 0x4f, 0x52, 0x43, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x02, 0x00, 0xf3, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
            0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x42,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00,
            0x04, 0x00, 0x40, 0x00, 0x09, 0x00, 0x08, 0x00,
        ];

        let result = ElfHeader::from_bytes(&bytes);

        assert_eq!(result, Err(ElfHeaderParseError::InvalidMagic));
    }

    #[test]
    fn invalid_bitness() {
        let bytes = vec![
            0x7f, 0x45, 0x4c, 0x46, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x02, 0x00, 0xf3, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
            0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x42,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00,
            0x04, 0x00, 0x40, 0x00, 0x09, 0x00, 0x08, 0x00,
        ];

        let result = ElfHeader::from_bytes(&bytes);

        assert_eq!(result, Err(ElfHeaderParseError::InvalidBitness(0x3)));
    }

    #[test]
    fn invalid_endianess() {
        let bytes = vec![
            0x7f, 0x45, 0x4c, 0x46, 0x02, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x02, 0x00, 0xf3, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
            0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x42,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00,
            0x04, 0x00, 0x40, 0x00, 0x09, 0x00, 0x08, 0x00,
        ];

        let result = ElfHeader::from_bytes(&bytes);

        assert_eq!(result, Err(ElfHeaderParseError::InvalidEndianess));
    }

    #[test]
    fn invalid_verion() {
        let bytes = vec![
            0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x02, 0x00, 0xf3, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
            0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x42,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00,
            0x04, 0x00, 0x40, 0x00, 0x09, 0x00, 0x08, 0x00,
        ];

        let result = ElfHeader::from_bytes(&bytes);

        assert_eq!(result, Err(ElfHeaderParseError::InvalidVersion(0x2)));
    }

    #[test]
    fn invalid_abi() {
        let bytes = vec![
            0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x02, 0x00, 0xf3, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
            0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x42,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00,
            0x04, 0x00, 0x40, 0x00, 0x09, 0x00, 0x08, 0x00,
        ];

        let result = ElfHeader::from_bytes(&bytes);

        assert_eq!(result, Err(ElfHeaderParseError::InvalidAbi(0x13)));
    }

    #[test]
    fn invalid_obj_type() {
        let bytes = vec![
            0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x05, 0x00, 0xf3, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
            0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x42,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00,
            0x04, 0x00, 0x40, 0x00, 0x09, 0x00, 0x08, 0x00,
        ];

        let result = ElfHeader::from_bytes(&bytes);

        assert_eq!(result, Err(ElfHeaderParseError::InvalidObjType(0x5)));
    }

    #[test]
    fn invalid_asi() {
        let bytes = vec![
            0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x02, 0x00, 0xf8, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
            0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x42,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00,
            0x04, 0x00, 0x40, 0x00, 0x09, 0x00, 0x08, 0x00,
        ];

        let result = ElfHeader::from_bytes(&bytes);

        assert_eq!(result, Err(ElfHeaderParseError::InvalidASI));
    }

    #[test]
    fn reserved_asi() {
        let bytes = vec![
            0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x02, 0x00, 0x0D, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
            0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x42,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00,
            0x04, 0x00, 0x40, 0x00, 0x09, 0x00, 0x08, 0x00,
        ];

        let result = ElfHeader::from_bytes(&bytes);

        assert_eq!(result, Err(ElfHeaderParseError::ReservedASI));
    }

    #[test]
    fn invalid_version_orig() {
        let bytes = vec![
            0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x02, 0x00, 0xf3, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
            0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x42,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00,
            0x04, 0x00, 0x40, 0x00, 0x09, 0x00, 0x08, 0x00,
        ];

        let result = ElfHeader::from_bytes(&bytes);

        assert_eq!(result, Err(ElfHeaderParseError::InvalidVersionOrig(0x02)));
    }

    #[test]
    fn invalid_size() {
        let bytes = vec![
            0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x02, 0x00, 0xf3, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
            0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x42,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x38, 0x00,
            0x04, 0x00, 0x40, 0x00, 0x09, 0x00, 0x08, 0x00,
        ];

        let result = ElfHeader::from_bytes(&bytes);

        assert_eq!(result, Err(ElfHeaderParseError::InvalidSize(0x50)));
    }
}

mod program_header {

    use crate::{
        data::{ProgramFlags, ProgramType},
        error::ProgramHeaderParseError,
        program_header::ProgramHeader,
        Address,
    };

    #[test]
    fn load() -> Result<(), ProgramHeaderParseError> {
        let bytes = vec![
            0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
            0x00, 0x00, 0x00, 0x00, 0xf3, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x20,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let header = ProgramHeader::from_bytes(&bytes, 0, 56)?;

        assert_eq!(
            header,
            ProgramHeader {
                program_type: ProgramType::Load,
                flags: ProgramFlags::Read | ProgramFlags::Exec,
                seg_offset: 0x1000,
                seg_v_addr: Address(0x80000000),
                seg_p_addr: Address(0x80000000),
                seg_f_size: Address(0x20f3),
                seg_m_size: Address(0x20f3),
                align: 0x1000
            }
        );

        Ok(())
    }

    #[test]
    fn invalid_program_type() {
        let bytes = vec![
            0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
            0x00, 0x00, 0x00, 0x00, 0xf3, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x20,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let result = ProgramHeader::from_bytes(&bytes, 0, 56);

        assert_eq!(
            result,
            Err(ProgramHeaderParseError::InvalidProgramType(0x05))
        );
    }

    #[test]
    fn invalid_flags() {
        let bytes = vec![
            0x01, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
            0x00, 0x00, 0x00, 0x00, 0xf3, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x20,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let result = ProgramHeader::from_bytes(&bytes, 0, 56);

        assert_eq!(result, Err(ProgramHeaderParseError::InvalidFlags));
    }
}

mod section_header {
    use crate::{
        data::{SectionFlags, SectionType},
        error::SectionHeaderParseError,
        section_header::{SectionHeader, SectionName},
        Address,
    };

    #[test]
    fn load() -> Result<(), SectionHeaderParseError> {
        let bytes = vec![
            0x1b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xE4, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let header = SectionHeader::from_bytes(&bytes, 0, 64)?;

        assert_eq!(
            header,
            SectionHeader {
                name: SectionName::Offset(27),
                sec_type: SectionType::Progbits,
                flags: SectionFlags::Alloc | SectionFlags::Execinstr,
                sec_addr: Address(0x080000000),
                sec_offset: 0x1000,
                sec_size: 0x20e4,
                sec_link: 0,
                sec_info: 0,
                sec_align: 0x4,
                sec_entry_size: None
            }
        );

        Ok(())
    }

    #[test]
    fn invalid_section_type() {
        let bytes = vec![
            0x1b, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xE4, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let result = SectionHeader::from_bytes(&bytes, 0, 64);

        assert_eq!(
            result,
            Err(SectionHeaderParseError::InvalidSectionType(0x14))
        );
    }

    #[test]
    fn invalid_flags() {
        let bytes = vec![
            0x1b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xE4, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let result = SectionHeader::from_bytes(&bytes, 0, 64);

        assert_eq!(result, Err(SectionHeaderParseError::InvalidFlags));
    }
}
